{"image": "image (1).webp", "text": "This image introduces functions in iCodeMath. Functions allow you to group a sequence of commands under a single name, making your code more organized and reusable. You define a function using 'def function_name():', and any commands indented below it become part of that function. For example, 'get_item()' is defined to move Dev forward and then back, acting as a shortcut for these steps."}
{"image": "image (2).webp", "text": "This image explains the 'Flyer.disappear()' condition. When a flying board or item disappears, this condition becomes 'True'. When it reappears, the condition is 'False'. It's crucial to remember that 'disappear()' can only be used as a condition within statements like 'if' or 'while', not as a direct command to make something disappear."}
{"image": "image (3).webp", "text": "This image demonstrates the 'while' statement, which is similar to an 'if-else' statement but creates a loop. The commands indented below 'while' will repeatedly execute as long as the specified condition remains 'True'. If the condition is 'False' from the start, the indented commands are skipped entirely, and the program moves on."}
{"image": "image (4).webp", "text": "This image illustrates the use of the 'wait()' command within a 'while' loop. When 'wait()' is encountered inside a 'while Flyer.disappear():' loop, the program will pause and wait until the 'Flyer' reappears (i.e., 'Flyer.disappear()' becomes 'False') before continuing to execute the commands that follow the 'wait()' command."}
{"image": "image (5).webp", "text": "This image explains 'nested for loops', which means placing one for loop inside another. When doing this, it's essential that the 'outer' loop and the 'inner' loop use different variable names (e.g., 'i' for the outer and 'j' for the inner) to avoid conflicts and ensure correct iteration. Proper indentation is also critical to define which commands belong to which loop."}
{"image": "image (6).webp", "text": "This image shows how to combine two conditions using the 'and' operator in an 'if' statement. For the command 'Dev.step(3)' to execute, *both* conditions connected by 'and' must be 'True'. If even one condition is 'False', the entire combined condition becomes 'False', and the command is skipped."}
{"image": "image (7).webp", "text": "This image demonstrates how to combine two conditions using the 'or' operator in an 'if' statement. When conditions are connected by 'or', the command 'Dev.step(3)' will execute if *at least one* of the conditions is 'True'. The command is only skipped if *both* conditions are 'False'."}
{"image": "image (8).webp", "text": "This image introduces the 'if-else' statement. This structure allows you to execute one set of commands if a condition is 'True' (under 'if') and a different set of commands if the same condition is 'False' (under 'else'). Commands following 'if' and 'else' must be indented 4 spaces to define their scope."}
{"image": "image (9).webp", "text": "This image explains how to check if an 'Item' is broken using 'Item[i].broken()'. If an item is a dangerous 'Red Energy item', 'Item[i].broken()' is 'True'. To ensure Dev only collects safe items, you should use an 'if' statement with 'not Item[i].broken()'. This condition is 'True' only if the item is *not* broken, allowing Dev to collect it."}
{"image": "image (10).webp", "text": "This image explains basic 'if' statements. An 'if' statement has a condition and an indented command. If the condition is 'True', the indented command (e.g., 'Dev.turnRight()') is executed. If the condition is 'False', the indented command is skipped. This allows Dev to make decisions based on the state of items or its position, like turning based on an item's x-coordinate relative to Dev's x-coordinate."}
{"image": "image (11).webp", "text": "This image explains how 'if' statements work to execute commands based on conditions. An 'if' statement has two parts: a condition (like 'Item.x < Dev.x') and a command (like 'Dev.turnRight()') that is indented 4 spaces below it. If the condition is True, the indented command is executed. If False, it's ignored. This allows Dev to make decisions, such as turning based on an item's position relative to its own."}
{"image": "image (12).webp", "text": "This image demonstrates how to calculate relative positions on the y-axis. By subtracting Dev's y-coordinate from an Item's y-coordinate ('Item[i].y - Dev.y'), you can determine if the item is in front (result > 0) or behind (result < 0) Dev. The absolute value of this difference can also be used to determine the number of steps Dev needs to move along the y-axis."}
{"image": "image (13).webp", "text": "This image illustrates how to calculate the distance 'd' between Dev and an Item using coordinate differences (Item.x - Dev.x or Item.y - Dev.y). Before using this calculation for movement, Dev must be facing the direction in which the coordinate value increases. If Dev is not facing the correct direction, a turning command (like 'Dev.turnRight()') is needed first."}
{"image": "image (14).webp", "text": "This image shows how to calculate distances using coordinates on a map grid, especially when the grid lines are not visible. The distance 'd' is found by subtracting Dev's x or y coordinate from the Item's x or y coordinate. For example, 'Spaceship.step(3)' moves 3 steps, and 'Spaceship.step(Energy.x - Spaceship.x)' moves based on the x-coordinate difference to reach an Energy item."}
{"image": "image (15).webp", "text": "This image introduces the concept of coordinates on the iCodeMath map grid. Every element like Dev, Spaceship, Flyer, and Items has a unique location defined by two numbers: an 'x' coordinate and a 'y' coordinate. You can find these values by hovering your mouse over the elements on the map, which helps in precisely locating and interacting with them in your code."}
{"image": "image (16).webp", "text": "This image reiterates a fundamental rule for the 'Flyer' robot: it can only move in the single direction indicated by the green checkmark and the corresponding arrow. All other directions, marked with red 'X's, are blocked and cannot be used for movement. This highlights the importance of orienting the Flyer correctly before attempting to move it."}
{"image": "image (17).webp", "text": "This image demonstrates how the loop variable 'i' can be used in calculations to determine the number of steps a 'Flyer' should move. The variable 'i' starts at 0 and increments by 1 with each iteration of the 'for i in range(3)' loop. For example, 'Flyer[i].step(i*2)' means the steps will be 0, then 2, then 4 for each respective iteration, allowing for dynamic movement patterns."}
{"image": "image (18).webp", "text": "This image explains how to use a 'for' loop with the loop variable 'i' to simplify code when performing the same action on multiple elements in a list. Instead of writing 'Flyer[0].step(1)', 'Flyer[1].step(1)', etc., you can use 'for i in range(3): Flyer[i].step(1)'. This iterates through 'Flyer[0]', 'Flyer[1]', and 'Flyer[2]', making the code more concise and efficient."}
{"image": "image (19).webp", "text": "This image defines 'Flyer' as a 'list' or group of flying boards. Each individual flying board within this group is considered an 'element' of the list. To identify and interact with a specific element, you use its 'index', which is a numerical position starting from 0. So, 'Flyer[0]' refers to the first board, 'Flyer[1]' to the second, and so on."}
{"image": "image (20).webp", "text": "This image illustrates the behavior of the loop variable 'i' in a 'for' loop defined by 'for i in range(3)'. The variable 'i' is initialized to 0. For each iteration of the loop, 'i' increases by 1. Therefore, in a loop that runs 3 times, 'i' will take on the values 0, then 1, and finally 2, which can be used to control actions like 'Dev.step(i)'."}
{"image": "image (21).webp", "text": "This image explains that multiple variables can be defined in the code, but each variable name must be unique and cannot be repeated. For example, variables 'a' and 'b' are defined with different values, and then used in 'Dev.step(a)' and 'Dev.step(b)' to control the robot's movement independently."}
{"image": "image (22).webp", "text": "This image demonstrates how the value of a variable can be changed while the code is running. For instance, 'a = a + 1' increases the value of variable 'a' by 1 each time it's executed. This allows for dynamic changes in behavior, such as a robot stepping a progressively increasing number of times within a loop."}
{"image": "image (23).webp", "text": "This image shows that variables, like the letter 'a', can be used to represent numbers in coding commands. This makes code more flexible. For example, 'a = 3' declares a variable 'a' with a value of 3. Then, 'Dev.step(a)' will perform the same action as 'Dev.step(3)', moving Dev 3 steps."}
{"image": "image.png", "text": "This image illustrates 'nested for loops', where one loop is placed inside another. It's crucial that the 'outer' and 'inner' loops use different variable names (e.g., 'i' and 'j') to avoid conflicts. Proper indentation is essential to define the scope of each loop and ensure commands execute correctly within their respective loops."}
{"image": "image.webp", "text": "This image explains how to add 'parameters' to functions, making them more versatile. By defining a function like 'def get_item(a):', you can pass a value (e.g., 'get_item(4)') to the parameter 'a' when you call the function. This allows the commands inside the function (like 'Dev.step(a)') to be executed with the specific value provided, enabling dynamic behavior."}
